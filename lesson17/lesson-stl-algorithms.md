**I. Введение.**

Сегодня мы поговорим о том, что такое алгоритмы STL в C++ и зачем они нужны. STL - это стандартная библиотека шаблонов, которая предоставляет нам множество полезных инструментов для работы с контейнерами и другими структурами данных. В состав STL входят множество алгоритмов, которые могут быть использованы для обработки коллекций данных разного типа.

Алгоритмы STL в C++ предоставляют реализации многих известных алгоритмов сортировки, поиска и трансформации данных, а также многие другие полезные функции. Их использование может значительно ускорить и упростить написание кода, позволяя программистам сконцентрироваться на более высокоуровневых задачах, вместо того, чтобы заниматься написанием базовых алгоритмов.

На этой лекции мы изучим основные алгоритмы STL, которые помогут вам работать с контейнерами и другими структурами данных в C++. 

Перейдем к основам алгоритмов. Что такое алгоритм? Алгоритм - это последовательность действий, которые необходимо выполнить, чтобы решить определенную задачу. В программировании алгоритмы используются для обработки данных, выполнения вычислений и других задач.

В STL в C++ есть множество алгоритмов, которые могут быть использованы для обработки коллекций данных. Они включают в себя алгоритмы сортировки, поиска, преобразования и многие другие. Давайте рассмотрим их подробнее.

**II. Основы алгоритмов.**

**Сортировка:**

- `std::sort` - сортировка элементов контейнера в порядке возрастания (по умолчанию) или в соответствии с определенным критерием. 

- `std::stable_sort` - сортировка элементов контейнера в порядке возрастания (по умолчанию) или в соответствии с определенным критерием с сохранением относительного порядка равных элементов. 

**Поиск:**

- `std::find` - поиск первого вхождения элемента в контейнере.

- `std::binary_search` - проверка наличия элемента в отсортированном контейнере с помощью бинарного поиска.

**Преобразование:**

- `std::transform` - применение операции к каждому элементу контейнера и сохранение результата в другой контейнер.

- `std::generate` - генерация последовательности элементов в контейнере с помощью заданной операции.

**Удаление и перемещение:**

- `std::remove` - удаление элементов из контейнера, удовлетворяющих заданному условию.

- `std::unique` - удаление дублирующихся элементов из контейнера.

- `std::copy` - копирование элементов из одного контейнера в другой.

**Другие алгоритмы:**

- `std::accumulate` - вычисление суммы элементов контейнера.

- `std::count` - подсчет числа элементов, удовлетворяющих заданному условию.

- `std::max_element` и `std::min_element` - поиск максимального и минимального элементов в контейнере.

Каждый из этих алгоритмов можно применять к разным типам контейнеров, например, к векторам, спискам, множествам и т.д. Рассмотрим несколько примеров использования этих алгоритмов на практике.

**Примеры использования алгоритмов:**

1. `std::sort`:

```c++
#include <iostream>
#include <algorithm>
#include <vector>

int main() {
  std::vector<int> v = {3, 5, 2, 8, 1, 6};

  // сортировка в порядке возрастания
  std::sort(v.begin(), v.end());

  // вывод отсортированного вектора
  for (int i : v) {
    std::cout << i << " ";
  }
  std::cout << std::endl;

  return 0;
}
```

Результат выполнения программы:

```bash
1 2 3 5 6 8
```

2. `std::find`:

```c++
#include <iostream>
#include <algorithm>
#include <vector>

int main() {
  std::vector<int> v = {3, 5, 2, 8, 1, 6};
  int x = 8;

  // поиск первого вхождения элемента
  auto it = std::find(v.begin(), v.end(), x);

  if (it != v.end()) {
    std::cout << "Element " << x << " found at position " << std::distance(v.begin(), it) << std::endl;
  } else {
    std::cout << "Element " << x << " not found" << std::endl;
  }

  return 0;
}
```

Результат выполнения программы:

```bash
Element 8 found at position 4
```

3. `std::transform`:

```c++
#include <iostream>
#include <algorithm>
#include <vector>

int main() {
  std::vector<int> v = {3, 5, 2, 8, 1, 6};
  std::vector<int> v2(v.size());

  // применение операции к каждому элементу и сохранение результата
  std::transform(v.begin(), v.end(), v2.begin(), [](int x) { return x * x; });

  // вывод нового вектора
  for (int i : v2) {
    std::cout << i << " ";
  }
  std::cout << std::endl;

  return 0;
}
```

Результат выполнения программы:

```bash
9 25 4 64 1 36
```

Это только некоторые примеры использования алгоритмов STL в C++. Важно понимать, что эти алгоритмы могут быть комбинированы и применены к различным типам контейнеров в зависимости от конкретной задачи.


**III. Итераторы ***
Итераторы в C++ - это объекты, которые используются для доступа к элементам контейнеров STL, таким как std::vector, std::list, std::map и другие. 


Определение итератора


Итератор - это объект, который можно использовать для перебора элементов контейнера. Он может указывать на любой элемент контейнера, и вы можете получить доступ к этому элементу, используя операторы соответствующего итератора. В зависимости от типа контейнера и требуемой функциональности, можно использовать различные типы итераторов.


Типы итераторов


C++ STL определяет 5 типов итераторов:



Input iterator (входной итератор)

Output iterator (выходной итератор)

Forward iterator (однонаправленный итератор)

Bidirectional iterator (двунаправленный итератор)

Random access iterator (итератор со случайным доступом)


**IV. Функторы.**
- Определение функтора
- Роль функторов в алгоритмах STL
- Примеры функторов в STL и их применение:
   - `std::greater`
   - `std::less`
   - `std::logical_and`
   - `std::logical_or`
   - `std::modulus`
   - `std::not1`
   - `std::bind1st`
   - `std::bind2nd`

Определение функтора:
Функтор в C++ - это объект или класс, который может быть использован как функция. Он перегружает оператор вызова функции () и может быть использован в алгоритмах STL в качестве параметра функции для реализации своей специфической логики.

Роль функторов в алгоритмах STL:
Функторы позволяют передать специализированную функциональность в алгоритмы STL. Они предоставляют более гибкий подход к изменению логики алгоритмов, благодаря чему алгоритм можно настроить под конкретные нужды и задачи.

Примеры функторов в STL и их применение:
Пример функтора negate для преобразования чисел в их отрицательный эквивалент:
```cpp
#include 
#include 
#include 
#include 


int main() {
    std::vector vec = {1, 2, 3, 4, 5};
    std::transform(vec.begin(), vec.end(), vec.begin(), std::negate());
    for (int i: vec) {
        std::cout << i << " ";
    }
    std::cout << std::endl;
    return 0;
}

```

Пример функтора greater для сравнения двух чисел:
```cpp
#include 
#include \n\nint main() {
    std::greater greater_func;
    std::cout << greater_func(3, 2) << std::endl; // 1
    std::cout << greater_func(2, 3) << std::endl; // 0
    return 0;
}
```
Пример функтора для удаления элементов из вектора:
```cpp
#include 
#include 
#include 


class GreaterThan {
    private:
        int m_threshold;\n    public:
        GreaterThan(int threshold) : m_threshold(threshold) {}
        bool operator() (int value) const {
            return value > m_threshold;\n        }
};


int main() {
    std::vector vec = {1, 2, 3, 4, 5};
    vec.erase(std::remove_if(vec.begin(), vec.end(), GreaterThan(3)), vec.end());
    for (int i: vec) {\n        std::cout << i << " ";
    }
    std::cout << std::endl;
    return 0;
}
```
Эти примеры демонстрируют различные способы использования функторов в STL для определенных задач и алгоритмов.

**V. Алгоритмы.**
- Описание алгоритмов STL:
   - `std::accumulate`
   - `std::adjacent_difference`
   - `std::all_of`
   - `std::any_of`
   - `std::copy`
   - `std::copy_if`
   - `std::copy_n`
   - `std::equal`
   - `std::fill`
   - `std::fill_n`
   - `std::for_each`
   - `std::generate`
   - `std::generate_n`
   - `std::includes`
   - `std::inner_product`
   - `std::is_partitioned`
   - `std::is_sorted`
   - `std::iter_swap`
   - `std::lexicographical_compare`
   - `std::make_heap`
   - `std::max`
   - `std::merge`
   - `std::min`
   - `std::mismatch`
   - `std::move`
   - `std::

Алгоритмы STL (Standard Template Library) - это функции, которые работают с контейнерами и другими структурами данных в C++. Они предназначены для упрощения типовых задач обработки контейнеров, таких как сортировка, поиск элементов, копирование, удаление элементов и т. д. Алгоритмы STL работают с любыми контейнерами, поддерживающими итераторы, и используются вместе с контейнерами STL. 


Основные категории алгоритмов STL:

- Неизменяемые алгоритмы: такие алгоритмы, которые не изменяют содержимое контейнера, с которым они работают, например, сортировка, поиск, сравнение, вывод на экран и т. д.

- Изменяемые алгоритмы: алгоритмы, которые изменяют содержимое контейнера, с которым они работают, например, перемешивание, корректировка размера контейнера, копирование, удаление элементов и др.

- Алгоритмы числовых операций: алгоритмы, которые работают с числовыми значениями, такие как сумма, среднее значение, произведение, агрегация и т. д.

- Алгоритмы перестановок: алгоритмы, которые меняют местами элементы контейнера, такие как перемещение, обмен, поворот и т. д.


**VI. Политики исполнения..**

Большинство алгоритмов имеют перегрузки, которые принимают политики выполнения. Алгоритмы стандартной библиотеки поддерживают несколько политик выполнения, а библиотека предоставляет соответствующие типы и объекты политик выполнения. Пользователи могут выбирать политику выполнения статически, вызывая параллельный алгоритм с объектом политики выполнения соответствующего типа.

Реализации стандартной библиотеки (но не пользователи) могут определять дополнительные политики выполнения как расширение. Семантика параллельных алгоритмов, вызываемых с помощью объекта политики выполнения типа, определяемого реализацией, определяется реализацией.

В C++ существуют четыре типа политик исполнения: sequenced_policy, parallel_policy, parallel_unsequenced_policy и unsequenced_policy. 


В стандарте C++17 были добавлены новые типы политик - unsequenced_policy. 


Эти типы политик исполнения определяют, как будет происходить исполнение операций, особенно в контексте алгоритмов параллельной обработки данных. 


Классы-политики реализованы как классы-маркеры с пустым телом, но с определенными типами-членами, которые могут быть использованы внутри алгоритмов. \n\nДоступны следующие типы политик исполнения: 

sequenced_policy (seq)

parallel_policy (par)

parallel_unsequenced_policy (par_unseq)

unsequenced_policy (C++17) (unseq)

Конкретный пример использования типов политик исполнения может выглядеть следующим образом:
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <execution> // библиотека, содержащая типы политик исполнения

int main() {
    std::vector<int> v {5, 7, 2, 8, 3, 1, 9, 4, 6};
    
    // применение алгоритма sort с использованием политики исполнения parallel_policy
    std::sort(std::execution::par, v.begin(), v.end());
    
    // вывод отсортированного вектора
    for (auto elem : v) {
        std::cout << elem << \" ";
    }
    std::cout << std::endl;
    
    return 0;
}
```
В данном примере происходит сортировка вектора v с помощью алгоритма std::sort, примененного с использованием политики исполнения parallel_policy (параллельное выполнение). После сортировки вектор выводится на экран. 

Кроме parallel_policy могут быть использованы другие типы политик исполнения (например, sequenced_policy, parallel_unsequenced_policy и unsequenced_policy), которые также могут влиять на способ выполнения операций в алгоритмах стандартной библиотеки.

**VI. Использование алгоритмов в своих программах.**
- Как использовать алгоритмы STL в своих программах
- Примеры использования алгоритмов STL для работы с контейнерами, массивами и указателями

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
  // использование алгоритмов STL для работы с vector
  std::vector<int> v = {3, 2, 1, 4, 5};
  std::sort(v.begin(), v.end());
  std::cout << \"Сортировка: ";
  for (auto i : v) std::cout << i << " ";
  std::cout << std::endl;

  int n = 3;
  bool result = std::binary_search(v.begin(), v.end(), n);
  std::cout << \"Бинарный поиск " << n << \": " << (result ? "найден" : "не найден") << std::endl;

  // использование алгоритмов STL для работы с массивами
  int arr[] = {3, 2, 1, 4, 5};
  std::sort(arr, arr + 5);
  std::cout << \"Сортировка: ";
  for (auto i : arr) std::cout << i << \" ";
  std::cout << std::endl;

  int* p = std::find(arr, arr + 5, 3);
  std::cout << \"Поиск указателя на 3: " << (p != arr + 5 ? std::to_string(*p) : "не найден") << std::endl;

  // использование алгоритмов STL для работы с указателями
  int* arrp[5];
  for (int i = 0; i < 5; i++) arrp[i] = &arr[i];

  std::sort(arrp, arrp + 5, [](int* a, int* b){ return *a < *b; });
  std::cout << \"Сортировка указателей: ";
  for (int i = 0; i < 5; i++) std::cout << *arrp[i] << \" ";
  std::cout << std::endl;

  return 0;
}
```

**VII. Заключение.**
В заключении нашей лекции о Standard Template Library мы можем подвести итоги того, что было изучено. Мы рассмотрели основные компоненты библиотеки STL: контейнеры, алгоритмы и итераторы. Контейнеры представляют собой структуры данных, которые позволяют хранить и управлять элементами внутри себя. Алгоритмы представлены набором функций для работы с контейнерами, такие как сортировка, поиск и т.д. Итераторы позволяют обходить элементы в контейнерах, что делает работу с ними ещё более гибкой.


Мы изучили несколько примеров работы с STL, включая сортировку, поиск элементов и копирование элементов из одного списка в другой.

Дальнейшее изучение STL может включать изучение более сложных контейнеров, таких как map, set, queue, stack и других. Также можно более подробно изучить элементы STL, которые мы рассмотрели сегодня, например, изучить другие алгоритмы, работающие с контейнерами. 

В целом, STL - это очень полезный инструмент в C++, который делает работу с контейнерами и алгоритмами более гибкой и удобной. С его помощью вы можете ускорить свою работу и уменьшить количество написанного кода.



Link lists
[algorithms](https://ru.cppreference.com/w/cpp/algorithm)
[Ограниченные алгоритмы (начиная с C++20)](https://ru.cppreference.com/w/cpp/algorithm/ranges)