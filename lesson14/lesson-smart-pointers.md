# Умные указатели

Введение:

Краткое напоминание о указателях в C++ и их использовании

Необходимость использования умных указателей


- Часть 1 - Умные указатели:

Shared pointers (std::shared_ptr) - определение, создание и особенности использования shared pointers

Weak pointers (std::weak_ptr) - определение, создание и особенности использования weak pointers

Unique pointers (std::unique_ptr) - определение, создание и особенности использования unique pointers

Comparing and converting smart pointers - сравнение и конвертирование умных указателей


- Часть 2 - Примеры использования:

Работа с динамической памятью - создание объектов в динамической памяти и их управление smart pointers

Работа с памятью, выделенной внешними библиотеками - использование smart pointers для освобождения памяти, выделенной внешней библиотекой

Работа с циклическими зависимостями - использование weak pointers для разрешения циклических зависимостей

- make_shared, make_unique
- dynamic_cast_shared, dynamic_cast_unique


Заключение:

Обзор преимуществ использования умных указателей в C++

Советы по использованию умных указателей для безопасной и эффективной работы с памятью

Вопросы и ответы.


## Введение

### Краткое напоминание о указателях в C++ и их использовании

Держите, пожалуйста, краткий рассказ на 5 минут о указателях в C++ и о том, как их использовать:


Указатель - это переменная, которая хранит адрес другой переменной. Он дает возможность получить доступ к значению по адресу и изменять его.


Создать указатель можно при помощи оператора "&", который берет адрес переменной. Например:

```cpp
int x = 10;
int *ptr = &x;
```

В этом примере мы создали указатель "ptr", который хранит адрес переменной "x".


Для доступа к значению по адресу используют оператор разыменования "*". Например:


```cpp
int x = 10;
int *ptr = &x;
*ptr = 20;

// x теперь равно 20
```

В этом примере мы использовали указатель "ptr" для изменения значения переменной "x".


Также указатели могут использоваться для динамического выделения памяти. Оператор "new" выделяет память для переменной и возвращает ее адрес:



```cpp
int *ptr = new int;
```

Этот код выделяет память для переменной типа "int" и сохраняет ее адрес в указатель "ptr".


Чтобы освободить память, занятую переменной, которую выделит "new", следует использовать оператор "delete":



```cpp
int *ptr = new int;
delete ptr;
```

Также можно создавать указатели на массивы:



```cpp
int arr[5];
int *ptr = &arr[0];

// или

int *ptr = new int[5];
```

В этом примере мы создали указатель "ptr", который указывает на первый элемент массива "arr".


Кроме того, указатели могут использоваться для передачи аргументов в функцию по ссылке:


```cpp
void foo(int *ptr) {
  *ptr = 20;
}

int x = 10;
foo(&x);

// x теперь равно 20
```

В этом примере мы передали указатель на переменную "x" в функцию "foo", которая изменила значение переменной "x" через указатель.

### Умные указатели в C++
- Что такое умные указатели?
- Особенности умных указателей
- Классы умных указателей в C++

Таким образом, указатели являются мощным инструментом в C++, позволяющим работать с памятью и передавать аргументы в функции по ссылке.

Умные указатели в C++ - это классы, которые предоставляют более удобный и безопасный способ работы с указателями. Они автоматически освобождают память, занимаемую объектом, на который указывает указатель, когда он уже не нужен. Кроме того, они гарантируют корректность удаления объекта и избегают утечек памяти.


Одной из особенностей умных указателей является автоматическое освобождение памяти при выходе из области видимости. Проще говоря, когда объект умного указателя удаляется, он автоматически удаляет объект, на который он указывал.


#### Классы умных указателей в C++ включают:



- shared_ptr: используется для управления ресурсами, которые могут иметь несколько владельцев. Он предоставляет счетчик ссылок, который отслеживает количество объектов, которые разделяют один и тот же ресурс. Объект удаляется только при достижении счетчика ссылок нуля.



- unique_ptr: используется для управления ресурсами, которые имеют единственного владельца. Он обеспечивает эксклюзивное владение ресурсом, поэтому только один unique_ptr может указывать на объект. Когда unique_ptr выходит из области видимости, он автоматически удаляет объект.



- weak_ptr: используется в связке с shared_ptr. Он может ссылаться на объект, управляемый shared_ptr, но не увеличивает его счетчик ссылок. Он не может использоваться для доступа к объекту напрямую, только через shared_ptr.


## Класс unique_ptr
- Что такое unique_ptr?
- Как использовать unique_ptr?
- Примеры использования unique_ptr

Расмотрим небольшой код

[uniqptr-ex.cpp](./code/uniqptr-ex.cpp)

Выходные данные:

``` bash
Created Object: 1
Value: 1
Destroyed Object: 1
End of function
```

Объект типа unique_ptr представляет собой специальный класс, который обеспечивает управление ресурсами, доступными только для одного указателя в каждый момент времени. Этот указатель привязан к единственному объекту и гарантирует, что только один unique_ptr будет ссылаться на объект в каждый момент времени.

Чтобы использовать unique_ptr, необходимо сначала создать его, указав тип объекта, на который он должен указывать. Затем можно использовать универсальный оператор -> для доступа к членам этого объекта.

Пример использования unique_ptr включает создание объекта и связанной с ним уникальной ссылки unique_ptr, а затем доступ к объекту через эту ссылку. Уникальная ссылка может быть перемещена с помощью функции std::move, что предоставляет возможность передать управление ресурсами другому unique_ptr. При этом исходный unique_ptr будет обнулен, а ресурсы будут переданы на новый указатель.


В этом примере мы создали объект TestClass, создали unique_ptr к нему, а затем переместили его на другую unique_ptr. Изначальный unique_ptr был обнулен и объект удалился при выходе из области видимости.

Еще один пример на unique_ptr
[uniqptr-ex2.cpp](./code/uniqptr-ex2.cpp)

В этом примере мы создаем класс FileReader, который открывает файл в конструкторе и предоставляет метод readLine() для чтения строк из файла. Мы используем умный указатель unique_ptr для автоматического управления памятью объекта FileReader. Если произойдет исключение при открытии файла, то мы перехватим его и выведем сообщение об ошибке. Если файл открылся успешно, то мы используем метод readLine() для чтения строк из файла и выводим их на экран.

Этот пример демонстрирует преимущества использования unique_ptr для автоматического освобождения памяти. Мы можем быть уверены, что объект FileReader будет удален, когда его не будет больше использоваться, даже если происходят исключения.

## Класс shared_ptr

Класс shared_ptr является умным указателем в C++, который автоматически управляет памятью объектов. Он работает по принципу подсчета ссылок, то есть хранит количество ссылок на объект и автоматически освобождает память, когда количество ссылок достигает нуля.


Для использования shared_ptr нужно создать объект с помощью оператора new и присвоить его shared_ptr. Например:
```cpp
std::shared_ptr<int> sharedPtr(new int(42));
```
Для доступа к объекту, на который указывает shared_ptr, можно использовать оператор * или -> как для обычных указателей:
```cpp
std::cout << *sharedPtr << std::cout;
```

Одна из особенностей shared_ptr - это возможность копирования и присваивания. Когда создается копия shared_ptr, увеличивается счетчик ссылок - новый shared_ptr и оригинальный shared_ptr указывают на один и тот же объект. Когда один из них уничтожается, счетчик ссылок уменьшается, и когда счетчик ссылок достигнет нуля, объект удаляется из памяти.


Однако, если два shared_ptr указывают на объект и один из них удаляется, а второй продолжает использовать объект, это может привести к ошибкам. Чтобы этого избежать, можно использовать weak_ptr, который не увеличивает счетчик ссылок и не препятствует уничтожению объекта.


Вот пример использования shared_ptr:
[sharptr-ex.cpp](./code/sharptr-ex.cpp)

В этом примере мы создаем shared_ptr, который указывает на объект типа int со значением 42. Затем мы создаем другой shared_ptr, который копирует первый shared_ptr. Оба shared_ptr указывают на один и тот же объект, поэтому, когда мы выводим значение по одному shared_ptr, это значение будет таким же, как и у другого shared_ptr.


После выхода из блока, в котором создана копия shared_ptr, счетчик ссылок на объект уменьшится до одного. Когда происходит уничтожение второго shared_ptr, объект не удаляется, так как первый shared_ptr продолжает ссылаться на него. Мы выводим значение объекта, на который указывает первый shared_ptr, и после завершения программы этот объект будет автоматически удален.

#### deleter

[sharptr-ex-deleter](./code/sharptr-ex-deleter.cpp)
В этом примере мы создаем std::ofstream объект, открываем файл для записи, а затем создаем std::shared_ptr с пользовательским удалятором. Пользовательский удалятор закрывает файл, используя метод close().


Затем мы записываем в файл с помощью std::ofstream, выдергивая указатель из std::shared_ptr. Обратите внимание, что мы обращаемся к файлу через оператор разыменовывания *outputFilePtr, потому что std::shared_ptr не перегружает операторы << и >>.


Когда outputFilePtr и outputFile удаляются в конце области видимости, пользовательский удалятор вызывается и закрывает файл.

## Класс weak_ptr

- weak_ptr является "слабым" (weak) указателем, который не владеет памятью объекта, на который он ссылается.

- Он используется для отслеживания существования объекта, на который указывает shared_ptr.

- weak_ptr можно создать из shared_ptr с помощью метода weak_ptr::lock(). Если объект, на который указывает shared_ptr, все еще существует, то weak_ptr::lock() вернет shared_ptr, который может быть использован для доступа к этому объекту.

- Если же объект, на который указывает shared_ptr, уже был удален, то weak_ptr::lock() вернет пустой shared_ptr.

Примеры использования weak_ptr:
[weakptr-ex.cpp](./code/weakptr-ex.cpp)

В данном примере, сначала создается shared_ptr, который владеет объектом Person с именем "Alice". Затем создается weak_ptr из personPtr методом lock(). После этого, мы проверяем существование объекта, на который указывает weak_ptr, с помощью метода lock().
Если объект еще существует, то мы можем использовать shared pointer, возвращенный lock() для доступа к этому объекту. Если же объект уже был удален, то lock() вернет пустой shared_ptr.
Затем мы удаляем shared_ptr с помощью метода reset(). После этого, мы снова проверяем существование объекта, на который указывает weak_ptr, и обнаруживаем, что он был удален.

```bash
Alice created.
Before deleting personPtr...
Accessing Alice through weak pointer.
After deleting personPtr...
Object already deleted.
Alice destroyed.
```

Более изящное использование weak_ptr может происходить вместе с использованием std::unique_ptr. Допустим, у нас есть класс Car, который может иметь несколько владельцев, и мы хотим реализовать возможность удаления объекта Car только тогда, когда не осталось больше владельцев. Для этого мы можем использовать std::shared_ptr и std::weak_ptr. Вот пример:
[weakptr-ex2.cpp](./code/weakptr-ex2.cpp)

## Как использовать умные указатели при проектировании классов и иерархии наследования?
При проектировании классов и иерархии наследования умные указатели могут быть полезны для управления ресурсами, которые могут быть выделены в конструкторе и освобождены в деструкторе объектов классов. Это может включать в себя управление связанными с классом объектами, такими как векторы или списки. 


Пример использования умных указателей в классе:

```cpp
class MyClass {
public:
    MyClass() : _data(new int(0)) {}
    // ...
private:
    std::unique_ptr<int> _data;
};
```

Здесь конструктор класса MyClass выделяет память для объекта типа int и присваивает ее умному указателю _data, который автоматически освободит память при уничтожении объекта MyClass.

При проектировании иерархии наследования, умные указатели могут быть использованы для управления владением объектами базового класса, чтобы избежать их утечек памяти. В этом случае следует использовать указатели на базовый класс с типом умного указателя на производный класс.


Пример использования умных указателей в иерархии наследования:

```cpp
class Base {
public:
    virtual ~Base() {}
    // ...
};

class Derived : public Base {
public:
    // ...
};

std::unique_ptr<Base> ptr(new Derived());
```

Здесь мы создаем умный указатель ptr на объект производного класса Derived, который наследуется от базового класса Base. При выходе из области видимости умный указатель автоматически удалит объект класса Derived.

## make_shared(C++11), make_unique(C++14)
Одно из основных преимуществ использования make_shared вместо прямого создания объектов с помощью оператора new заключается в более оптимизированном использовании памяти. 


В make_shared память для объекта и управляющего блока выделяется вместе как единое целое, что означает, что в случае создания нескольких умных указателей на этот объект, управляющий блок будет использоваться единожды. Это может существенно снизить количество аллокаций памяти и повысить производительность.


Пример использования make_shared:
```cpp
// создание объекта и управляющего блока в едином блоке памяти с использованием make_shared
std::shared_ptr<int> myPtr = std::make_shared<int>(42);

// создание двух разных объектов и двух управляющих блоков с использованием new
std::shared_ptr<int> myPtr1(new int(42));
std::shared_ptr<int> myPtr2(new int(42));
```

Здесь myPtr1 и myPtr2 создаются с помощью оператора new, что означает, что для каждого из них будет выделена отдельная область памяти для управляющего блока. В то же время, myPtr создается с помощью make_shared, что позволяет выделить объкт и управдяющий блок в заранее зарезервированном блоке памяти, что приводит к экономии.

Также стоит отметить, что при создании объектов make_shared передает аргументы с помощью шаблонных параметров, что позволяет избежать дополнительных копирований при передаче аргументов, что тоже может способствовать увеличению производительности.



# Выводы и заключение
В заключение, использование умных указателей может значительно облегчить работу с ресурсами, уменьшить вероятность ошибок и сделать код более безопасным и надежным.



### links
- [Passing smart pointers](https://www.modernescpp.com/index.php/c-core-guidelines-passing-smart-pointer)
- [Core Guidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)
- [Lib memory](https://en.cppreference.com/w/cpp/header/memory)