# STL iterators
## Введение (5 минут)

Стандартная библиотека шаблонов (STL) является частью стандартной библиотеки языка программирования C++. Она содержит широкий спектр классов, функций и контейнеров, которые обеспечивают гибкую и эффективную работу с данными. Один из основных компонентов STL - это итераторы.

Итераторы - это объекты, которые используются для обхода и манипулирования элементами контейнеров STL, таких как векторы, списки, деки и другие. Итераторы предоставляют универсальный способ доступа к элементам контейнеров, что делает код более гибким и удобным для чтения.

Итераторы позволяют нам выполнять множество операций с контейнерами, таких как добавление, удаление, поиск, сортировка и т.д. Они также могут использоваться в алгоритмах, которые могут быть применены к различным контейнерам, что делает их универсальными и гибкими.

Итераторы являются важной частью языка C++, и их понимание очень важно для разработчиков, которые работают с контейнерами STL. В дальнейшем мы рассмотрим различные категории итераторов, а также операции, которые могут быть выполнены с помощью итераторов.

## II. Категории итераторов (15 минут)

В STL выделяют пять категорий итераторов, каждая из которых поддерживает определенный набор операций и обладает своими особенностями.

1. Input Iterator (Итератор ввода)
Итераторы ввода позволяют проходить по контейнеру в одном направлении, только для чтения. Итераторы ввода поддерживают операции сравнения (==, !=), префиксный инкремент (++) и доступ к значениям через оператор разыменования (*). Они могут быть использованы для выполнения операций ввода данных из потока ввода.

2. Output Iterator (Итератор вывода)
Итераторы вывода позволяют проходить по контейнеру в одном направлении, только для записи. Итераторы вывода поддерживают операции сравнения (==, !=), префиксный инкремент (++) и доступ к значениям через оператор разыменования (*). Они могут быть использованы для выполнения операций вывода данных в поток вывода.

3. Forward Iterator (Однонаправленный итератор)
Итераторы однонаправленного движения позволяют проходить по контейнеру в одном направлении. Итераторы однонаправленного движения поддерживают операции сравнения (==, !=), префиксный инкремент (++) и доступ к значениям через оператор разыменования (*). Они могут быть использованы для выполнения операций поиска, обхода контейнера, а также для выполнения операций вставки и удаления элементов в контейнере.

4. Bidirectional Iterator (Двунаправленный итератор)
Итераторы двунаправленного движения позволяют проходить по контейнеру в обоих направлениях. Итераторы двунаправленного движения поддерживают операции сравнения (==, !=), префиксный и постфиксный инкремент (++, --) и доступ к значениям через оператор разыменования (*). Они могут быть использованы для выполнения операций вставки и удаления элементов в контейнере, а также для выполнения операций, требующих двунаправленного обхода контейнера.

5. Random Access Iterator (Итератор произвольного доступа)
Итераторы произвольного доступа позволяют проходить по контейнеру в любом направлении, с использованием операций смещения. Итераторы произвольного доступа поддерживают все операции, которые поддерживают итераторы двунаправленного движения, а также операции смещения (+,-), доступ к элементам через оператор индексации ([]), а также операции сравнения относительно позиции в контейнере (<, >, <=, >=). Они могут быть использованы для выполнения операций, требующих быстрого доступа к элементам контейнера по индексу, таких как сортировка и поиск.

Различия между категориями итераторов заключаются в наборе поддерживаемых операций и скорости выполнения этих операций. Итераторы произвольного доступа наиболее эффективны, но не все контейнеры поддерживают их. Итераторы однонаправленного движения являются наименее функциональными, но могут быть использованы в большинстве случаев, когда требуется простой доступ к элементам контейнера.

Класс `std::ostream_iterator` из STL позволяет использовать итератор для вывода данных в поток. Вот пример использования `std::ostream_iterator` для вывода содержимого вектора на экран:

```cpp
#include <iostream>
#include <vector>
#include <iterator>  // для std::ostream_iterator

int main() {
    // Создание вектора и заполнение его значениями
    std::vector<int> v{5, 2, 8, 3, 1};

    // Использование ostream_iterator для вывода содержимого вектора на экран
    std::copy(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, " "));
    std::cout << std::endl;

    return 0;
}
```

Здесь мы создаем вектор `v` с пятью значениями, а затем используем `std::copy()` для копирования значений вектора в стандартный поток вывода `std::cout`. Для этого мы создаем `std::ostream_iterator` с `std::cout` в качестве потока вывода и пробелом в качестве разделителя между значениями. Затем мы передаем этот итератор в функцию `std::copy()` в качестве аргумента `output_iterator`, чтобы скопировать значения вектора в поток вывода.

Этот пример демонстрирует, как использовать `std::ostream_iterator` для вывода содержимого контейнера на экран. Мы также могли бы использовать `std::ofstream` в качестве потока вывода, чтобы записать данные в файл вместо вывода на экран.

## III. Операции итераторов (20 минут)

Операции итераторов представляют набор методов, которые поддерживаются различными категориями итераторов. Вот некоторые из них:

1. Операции, поддерживаемые всеми итераторами:
   - `operator*()`: разыменование итератора, возвращает ссылку на текущий элемент контейнера.
   - `operator++()`: инкремент итератора, перемещает итератор на следующий элемент контейнера.
   - `operator!=()`: сравнение итераторов на неравенство.
   
2. Операции, поддерживаемые только итераторами входного потока (input iterators):
   - `operator++(int)`: инкремент итератора, перемещает итератор на следующий элемент контейнера, но возвращает копию итератора до инкремента.
   - `operator==()`: сравнение итераторов на равенство.
   - `operator->()`: доступ к членам текущего элемента контейнера.
   - `operator+(int)`: перемещение итератора на указанное число элементов контейнера вперед.
   - `operator+=(int)`: смещение итератора на указанное число элементов контейнера вперед.

3. Операции, поддерживаемые только итераторами выходного потока (output iterators):
   - `operator++(int)`: инкремент итератора, перемещает итератор на следующий элемент контейнера, но возвращает копию итератора до инкремента.
   - `operator=(const T&)`: присваивание значения текущему элементу контейнера.

4. Операции, поддерживаемые только итераторами прямого доступа (random access iterators):
   - `operator--()`: декремент итератора, перемещает итератор на предыдущий элемент контейнера.
   - `operator+(int)`: перемещение итератора на указанное число элементов контейнера вперед.
   - `operator+=(int)`: смещение итератора на указанное число элементов контейнера вперед.
   - `operator-(int)`: перемещение итератора на указанное число элементов контейнера назад.
   - `operator-=(int)`: смещение итератора на указанное число элементов контейнера назад.
   - `operator[](int)`: доступ к элементу контейнера с указанным смещением от текущего элемента.

В STL есть несколько методов, которые возвращают итераторы для контейнеров. Некоторые из них:
- `begin()`: возвращает итератор на первый элемент контейнера.
- `end()`: возвращает итератор на элемент следующий за последним элементом контейнера.
- `rbegin()`: возвращает обратный итератор на последний элемент контейнера
- `rend()`: возвращает обратный итератор на элемент перед первым элементом контейнера.

Эти методы могут быть использованы для итерации по контейнеру, например, в цикле for:

```c++
vector<int> v = {1, 2, 3, 4, 5};
for (auto it = v.begin(); it != v.end(); ++it) {
    cout << *it << " ";
}
```

В этом примере мы используем итераторы начала и конца вектора, чтобы пройти по всем его элементам и вывести их на экран.

Можно также использовать обратные итераторы для обхода контейнера в обратном порядке:

```c++
vector<int> v = {1, 2, 3, 4, 5};
for (auto it = v.rbegin(); it != v.rend(); ++it) {
    cout << *it << " ";
}
```

В этом примере мы используем обратные итераторы начала и конца вектора, чтобы пройти по всем его элементам в обратном порядке и вывести их на экран.

Также можно использовать операции итераторов для выполнения других действий, например, копирования элементов из одного контейнера в другой:

```c++
vector<int> v1 = {1, 2, 3, 4, 5};
vector<int> v2;

copy(v1.begin(), v1.end(), back_inserter(v2));
```

В этом примере мы используем функцию `copy`, которая копирует элементы из вектора `v1` в вектор `v2` с помощью операции `operator=` итераторов выходного потока и метода `back_inserter`, который добавляет элементы в конец вектора `v2`.

## IV. Использование итераторов в алгоритмах STL (20 минут)
- Обзор алгоритмов STL, которые принимают итераторы в качестве аргументов
- Примеры использования алгоритмов STL с итераторами: `sort()`, `find()`, `transform()`, `accumulate()`, etc.

STL также содержит большое количество алгоритмов, которые работают с контейнерами через итераторы. Например, функция `sort` используется для сортировки элементов контейнера:

```c++
vector<int> v = {5, 2, 4, 1, 3};
sort(v.begin(), v.end());
```

В этом примере мы использовали итераторы начала и конца вектора для сортировки его элементов.

Функция `find` позволяет найти элемент в контейнере:

```c++
vector<int> v = {5, 2, 4, 1, 3};
auto it = find(v.begin(), v.end(), 4);
if (it != v.end()) {
    cout << "Element found at position " << distance(v.begin(), it) << endl;
} else {
    cout << "Element not found" << endl;
}
```

В этом примере мы использовали функцию `find`, чтобы найти элемент со значением 4 в векторе `v`. Если элемент найден, мы выводим его позицию в контейнере с помощью функции `distance`, которая вычисляет расстояние между двумя итераторами.

Функция `transform` применяет операцию к каждому элементу контейнера:

```c++
vector<int> v = {1, 2, 3, 4, 5};
vector<int> v2(v.size());
transform(v.begin(), v.end(), v2.begin(), [](int i) { return i * i; });
```

В этом примере мы использовали функцию `transform`, чтобы возвести в квадрат каждый элемент вектора `v` и сохранить результат в векторе `v2`.

Функция `accumulate` суммирует все элементы контейнера:

```c++
vector<int> v = {1, 2, 3, 4, 5};
int sum = accumulate(v.begin(), v.end(), 0);
cout << "Sum of elements: " << sum << endl;
```

В этом примере мы использовали функцию `accumulate`, чтобы вычислить сумму всех элементов вектора `v`.

## V. Итераторы в пользовательских контейнерах (20 минут)
- Реализация итераторов в пользовательских контейнерах
- Использование пользовательских итераторов в алгоритмах STL

Пользовательские контейнеры могут реализовывать свои собственные итераторы. Для этого необходимо определить типы итераторов, которые будут поддерживаться, а также методы их доступа.

Рассмотрим пример создания пользовательского контейнера `MyContainer` с использованием итераторов:

```c++
#include <iostream>
#include <vector>

using namespace std;

class MyIterator {
public:
    using value_type = int;
    using difference_type = int;
    using pointer = int*;
    using reference = int&;
    using iterator_category = bidirectional_iterator_tag;

    MyIterator(pointer ptr) : ptr_(ptr) {}
    MyIterator& operator++() {
        ++ptr_;
        return *this;
    }
    MyIterator operator++(int) {
        MyIterator temp(*this);
        ++ptr_;
        return temp;
    }
    MyIterator& operator--() {
        --ptr_;
        return *this;
    }
    MyIterator operator--(int) {
        MyIterator temp(*this);
        --ptr_;
        return temp;
    }
    reference operator*() const { return *ptr_; }
    pointer operator->() const { return ptr_; }
    bool operator==(const MyIterator& other) const { return ptr_ == other.ptr_; }
    bool operator!=(const MyIterator& other) const { return !(*this == other); }
private:
    pointer ptr_;
};

class MyContainer {
public:
    using iterator = MyIterator;

    MyContainer() {}
    iterator begin() { return iterator(data_.data()); }
    iterator end() { return iterator(data_.data() + data_.size()); }

    void push_back(int value) { data_.push_back(value); }
    size_t size() const { return data_.size(); }
private:
    vector<int> data_;
};

int main() {
    MyContainer container;
    container.push_back(1);
    container.push_back(2);
    container.push_back(3);

    for (auto it = container.begin(); it != container.end(); ++it) {
        cout << *it << " ";
    }
    cout << endl;
    return 0;
}
```

В этом примере мы создали пользовательский контейнер `MyContainer`, который содержит вектор целых чисел. Мы также создали класс `MyIterator`, который является пользовательским итератором с двунаправленным доступом и поддерживает все необходимые операции для работы с алгоритмами STL.

В методах `begin()` и `end()` контейнера мы возвращаем объекты `MyIterator`, соответствующие началу и концу вектора `data_`.

Затем мы добавляем несколько элементов в контейнер `container` и выводим их значения, используя пользовательский итератор, в цикле `for`.

## Оптимизация работы с итераторами

При работе с итераторами в STL можно применять различные техники оптимизации, которые позволяют ускорить выполнение программы и снизить затраты на использование итераторов.

1. Использование константных итераторов для оптимизации

Использование константных итераторов может быть полезно, когда мы не планируем изменять элементы, на которые они указывают. В этом случае компилятор может оптимизировать код, что приведет к ускорению работы программы. Константный итератор объявляется с помощью ключевого слова const и может использоваться для доступа только к элементам контейнера, но не для их изменения.

Например, если мы работаем с контейнером vector и не планируем изменять его элементы, мы можем использовать константный итератор вместо обычного:

```cpp
std::vector<int> v {1, 2, 3, 4, 5};
std::vector<int>::const_iterator it = v.begin();

for (; it != v.end(); ++it) {
    std::cout << *it << " ";
}
```

2. Использование итераторов для удаления элементов из контейнеров с минимальными затратами

При удалении элементов из контейнеров в STL можно использовать различные техники, которые позволяют снизить затраты на выполнение операции удаления. Одной из таких техник является использование итераторов для удаления элементов с минимальными затратами.

В контейнерах, которые поддерживают быстрое удаление элементов по индексу, таких как vector или deque, мы можем использовать функцию erase для удаления элементов с помощью итераторов. Эта функция удаляет элементы из контейнера и возвращает итератор, указывающий на следующий элемент после удаленного. Это позволяет избежать лишних копирований элементов и снизить затраты на выполнение операции удаления.

Например, если мы хотим удалить все элементы вектора, которые меньше 3, мы можем использовать следующий код:

```cpp
std::vector<int> v {1, 2, 3, 4, 5};
for (auto it = v.begin(); it != v.end(); ) {
    if (*it < 3) {
        it = v.erase(it);
    }
    else {
        ++it;
    }
}
```

В этом примере мы проходимся по всем элементам вектора и удаляем те, которые меньше 3. Использование функции erase с итератором позволяет нам удалить элементы с минимальными затратами.

### Использование std::move_iterator для перемещения элементов
Использование `std::move_iterator` позволяет перемещать элементы контейнера вместо их копирования. Это может существенно повысить производительность при работе с большими контейнерами.

Пример:

```c++
#include <iostream>
#include <vector>
#include <iterator>
#include <algorithm>

int main() {
    std::vector<int> vec1 = {1, 2, 3, 4, 5};
    std::vector<int> vec2;

    // Стандартный способ копирования элементов
    std::copy(vec1.begin(), vec1.end(), std::back_inserter(vec2));

    // Использование move итератора для перемещения элементов
    std::move(vec1.begin(), vec1.end(), std::back_inserter(vec2));

    std::cout << "vec1: ";
    for (const auto& x : vec1) {
        std::cout << x << " ";
    }
    std::cout << std::endl;

    std::cout << "vec2: ";
    for (const auto& x : vec2) {
        std::cout << x << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

Результат:

```bash
vec1: 1 2 3 4 5
vec2: 1 2 3 4 5 1 2 3 4 5
```

Здесь первый вызов `std::copy` копирует элементы из `vec1` в `vec2`, а второй вызов `std::move` перемещает элементы из `vec1` в `vec2`.

## VII. Практические примеры использования итераторов (20 минут)

- Использование итераторов для перебора элементов контейнера в цикле
[for-loop.cpp](./code/for-loop.cpp)
- Использование итераторов для работы с файлами и потоками ввода/вывода
[for-input.cpp](./code/for-input.cpp)
- Использование итераторов для реализации алгоритмов на графах и деревьях
Пример кода, использующего итераторы для работы с графом:
В данном примере мы создаем граф и используем итераторы для перебора всех соседей вершины во время обхода графа в ширину (BFS).
[for-tree.cpp](./code/for-tree.cpp)
- Примеры использования итераторов в стандартных контейнерах STL (vector, list, set, map и др.)
[for-container.cpp](./code/for-container.cpp)

Различные контейнеры в STL могут иметь разное поведение при использовании итераторов. Например, для векторов (vector) и динамических массивов (array) доступ к элементам осуществляется за константное время с помощью оператора [], поэтому проход по ним с помощью итераторов будет иметь высокую производительность.

Однако для списков (list) доступ к элементам может занимать линейное время, поэтому проход по списку с помощью итераторов может быть неэффективным. Вместо этого рекомендуется использовать итераторы с прямым переходом (forward iterator) или двунаправленные итераторы (bidirectional iterator), чтобы избежать лишнего копирования элементов.

Для ассоциативных контейнеров (set, map, unordered_set, unordered_map и др.) итераторы обычно имеют сложность доступа O(log N), где N - количество элементов в контейнере. В этом случае проход по контейнеру с помощью итераторов может быть заметно медленнее, чем простое перечисление всех элементов с помощью цикла for.

В целом, выбор контейнера и типа итератора зависит от конкретной задачи и ее требований к производительности.

## VI. Заключение (5 минут)
- Итоги лекции
- Ссылки на дополнительные ресурсы

В заключении лекции мы подведем итоги, основные понятия и операции, связанные с итераторами в STL.
Итак, мы рассмотрели итераторы в STL и узнали, что они представляют собой объекты, которые позволяют перебирать элементы в контейнерах. Мы рассмотрели различные категории итераторов и основные операции, которые поддерживаются каждой из них. Кроме того, мы создали свой собственный пользовательский контейнер и итератор для него.

Итераторы представляют собой мощный инструмент для работы с контейнерами и позволяют эффективно и удобно перебирать элементы в контейнерах. Они широко используются в STL, и знание их работы является важным для любого разработчика, использующего C++.

Для дальнейшего изучения рекомендуем обратиться к следующим ресурсам:
Link lists
- [iterators](https://ru.cppreference.com/w/cpp/iterator)
- [Стандартная библиотека C++ (STL)](https://en.cppreference.com/w/cpp/header)
- [Статья "Iterators in C++ STL"](https://www.geeksforgeeks.org/iterators-c-stl/)
- [Статья "C++ Standard Library: Iterators"](https://www.modernescpp.com/index.php/c-core-guidelines-iterators)
- Книга "The C++ Standard Library" by Nicolai M. Josuttis.
- Effective STL (Scott Meyers), глава 4: Iterators, глава 9: Algorithms
- The C++ Programming Language (Bjarne Stroustrup), глава 24: Containers and Iterators
