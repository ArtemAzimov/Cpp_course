Постоянная рубрика ДЗ:

Нужно написать тот же список, только используя динамическую память. Это дает такие преимущества как возможность не создавать каждый узел (ноду) вручную.

Необходимые функции:

t_list* create_node(int data);
void push_node(t_list** head, t_list* node);
void show_list(t_list* head);

Первая создаёт ноду в динамической памяти и возвращает на неё указатель. С аргументом очевидно что делать, а указатель next новой ноды = nullptr.

Вторая получает указатель на первую ноду и новую ноду, которую нужно добавить в конец всей цепочки. Что за **? Указатель на указатель. Чтобы передать указатель на указатель на первую ноду делаем так: push_node(&head_node, ...
Где head_node это указатель на первую ноду. То есть, передаем адрес указателя, что в самой функции будет восприниматься как указатель на указатель. Так как само выражение &pointer возвращает значение типа указатель на указатель.

Как с этим работать. Чтобы получить значение, разыменовываем ук. на ук. так: **p. Чтобы получить сам ук. разыменовываем один раз  так: *p

Пример: (**p).data; *p = nullptr;

Третья функция получает указатель на первую ноду и выводит весь список. Тут для вас ничего нового.

Будет хорошо, если вы сможете написать так, чтобы количество нод вводилось из терминала. С возможностью ввести значение для каждой новой, конечно.
Если слишком запарно, можете в цикле где будете создавать лист, задать количество нод с помощью константы и значения задавать i.
Но нельзя создавать все ноды вручную как мы делали в прошлом задании. Должен работать цикл.

Сделайте пока как умеете, а потом я покажу как можно работать с указателями на структуры более удобным способом, с меньшим количеством запар со скобками.

В качестве опционального LVL 2, можете сделать 4 отельных листа и переформатировать их в двумерный массив, где каждая строка будет представлять собой один лист.
