#include <iostream>

using namespace std;

class MyClass
{
    /* конструктор копии  - полностью копирует значения оригинала, указывают в одно и то же место. После смерти объекта очистит это место для обоих
    вызывается по умолчанию, прописывать только если надо изименить поведение */
    MyClass(const MyClass& other)
    {
        length = other.length;
        name = other.name;

        name = new char[length]; // выделение новой памяти под копию

        for (unsigned i = 0; i < other.length; i++) // посимвольно копирует из other (оригинал) в копию
            name[i] = other.name[i];
    }

    MyClass obj(length, str);
    obj.show_name(); // скидываем в функцию по значению - 

    MyClass (MyClass&&)
    {

    }

    // указатель на базовый класс может также указывать на объект дочернего класса - фундаментальное свойство полиморфизма
    // взаимозаменяемость - выбор возвращаемого типа в рантайме
    Based* whoami = new Libtard("I'm batman", "I'm vengeance...");
    Based *p;
    Libtard l;
    p = &l;

    whoami->show();
    delete whoami;
    /* обычный деструктор удалит Based (базовый)
    нужен виртуальный деструктор*/ 
    virtual ~Based(){}

    // чтобы компилятор во время райнтайма мог понять на какой тип он указывает
    // виртуальные методы
    virtual void show() {} // - в базовом
    // при объявлении виртуального метода для объектного файла (бинарник) будет создана таблица виртуальных методов "virttable"
    // при рантайме сверяется с вирттейбл, есть ли еще методы
    void show() override {} // - в потомке

}


int main()
{

}